package com.hartwig.hmftools.sage.candidate_;

import static java.lang.Math.max;

import static com.hartwig.hmftools.sage.SageConstants.DEFAULT_READ_LENGTH;
import static com.hartwig.hmftools.sage.common.EvictingArray.MIN_CAPACITY;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Stream;

import com.google.common.collect.Lists;
import com.hartwig.hmftools.common.codon.Nucleotides;
import com.hartwig.hmftools.common.region.BaseRegion;
import com.hartwig.hmftools.common.variant.hotspot.VariantHotspot;
import com.hartwig.hmftools.sage.SageConfig;
import com.hartwig.hmftools.sage.common.EvictingArray;
import com.hartwig.hmftools.sage.select.HotspotSelector;
import com.hartwig.hmftools.sage.select.PanelSelector;

/**
 * A ring buffer of RefContexts by position.
 * Allows us to only store the ones that can be updated by upcoming reads.
 * Saves the AltContexts generated by these ref contexts that pass certain filters.
 */
public class RefContextCache_
{
    private final SageConfig mConfig;
    private final EvictingArray mEvictingArray;
    private final PanelSelector mPanelSelector;
    private final List<AltContext_> mSavedCandidates;
    private final HotspotSelector mHotspotSelector;

    public RefContextCache_(final SageConfig config, final List<VariantHotspot> hotspots, final List<BaseRegion> panel)
    {
        mConfig = config;
        mPanelSelector = new PanelSelector(panel);
        mSavedCandidates = Lists.newArrayList();

        mHotspotSelector = new HotspotSelector(hotspots);

        final Consumer<RefContext_> evictionHandler = (refContext) -> processAltContexts(refContext);

        int minCapacity = config.getReadLength() == DEFAULT_READ_LENGTH ?
                MIN_CAPACITY : max(MIN_CAPACITY, config.getReadLength() * 2);

        mEvictingArray = new EvictingArray(minCapacity, evictionHandler);
    }

    /**
     * This is the eviction handler. Gets all the alt contexts from the associated ref contexts and saves the candidates.
     * @param refContext The ref context for each position in the eviction array.
     */
    private void processAltContexts(final RefContext_ refContext)
    {
        if (refContext.altContexts() == null)
            return;

        Stream<AltContext_> altContexts = refContext.altContexts().stream();

        altContexts = altContexts.filter(RefContextCache_::hasValidDnaBases).filter(this::passesTumorHardLimits);

        altContexts.forEach(altContext -> {
            altContext.selectCandidates();

            if (altContext.hasValidCandidate())
                mSavedCandidates.add(altContext);

            if (altContext.hasSecondCandidate())
                mSavedCandidates.add(altContext.secondCandidate());
        });
    }

    /**
     * Does the ref of altContext contain all valid DNA bases?
     */
    private static boolean hasValidDnaBases(final AltContext_ altContext)
    {
        for (int i = 0; i < altContext.ref().length(); ++i)
        {
            if (!Nucleotides.isValidDnaBase(altContext.ref().charAt(i)))
                return false;
        }

        return true;
    }

    /**
     * Returns whether an AltContext pass the hard filters.
     */
    public boolean passesTumorHardLimits(final AltContext_ altContext)
    {
        if(mHotspotSelector.isHotspot(altContext))
            return true;

        return altContext.rawAltBaseQuality() >= mConfig.Filter.HardMinTumorRawBaseQuality
                && altContext.rawAltSupport() >= mConfig.Filter.HardMinTumorRawAltSupport;
    }

    /**
     * Register depth limit of underlying EvictionArray.
     */
    public void registerDepthLimit(int position, int limit) { mEvictingArray.registerDepthLimit(position, limit);}

    /**
     * Increment depth at position of the underling EvictionArray.
     */
    public void incrementDepth(int position) { mEvictingArray.registerDepth(position); }

    /**
     * Does the underlying EvictionArray exceeds depth limit at position.
     */
    public Boolean exceedsDepthLimit(int position) { return mEvictingArray.exceedsDepthLimit(position); }

    /**
     * Get or create the ref context based on the reads at the GenomePosition based on the reads in the underling EvictionArray.
     */
    public RefContext_ getOrCreateRefContext(final String chromosome, int position)
    {
        return mEvictingArray.getOrCreateRefContext(position, aLong -> new RefContext_(chromosome, position));
    }

    /**
     * Flush the EvictionArray which saves the candidates, and returns a sorted list of these saved candidates.
     */
    public List<AltContext_> altContexts()
    {
        mEvictingArray.evictAll();
        Collections.sort(mSavedCandidates);
        return mSavedCandidates;
    }

    public PanelSelector panelSelector() { return mPanelSelector; }
}
